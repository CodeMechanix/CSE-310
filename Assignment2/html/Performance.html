<html lang="en">
<head>
<title>Performance - Lexical Analysis With Flex</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Lexical Analysis With Flex">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Scanner-Options.html#Scanner-Options" title="Scanner Options">
<link rel="next" href="Cxx.html#Cxx" title="Cxx">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
The flex manual is placed under the same licensing conditions as the
rest of flex:

Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007 The Flex
Project.

Copyright (C) 1990, 1997 The Regents of the University of California.
All rights reserved.

This code is derived from software contributed to Berkeley by
Vern Paxson.

The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
  1.  Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the
     distribution.

Neither the name of the University nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Performance"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Cxx.html#Cxx">Cxx</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Scanner-Options.html#Scanner-Options">Scanner Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">17 Performance Considerations</h2>

<p><a name="index-performance_002c-considerations-373"></a>The main design goal of <code>flex</code> is that it generate high-performance
scanners.  It has been optimized for dealing well with large sets of
rules.  Aside from the effects on scanner speed of the table compression
&lsquo;<samp><span class="samp">-C</span></samp>&rsquo; options outlined above, there are a number of options/actions
which degrade performance.  These are, from most expensive to least:

   <p><a name="index-REJECT_002c-performance-costs-374"></a><a name="index-yylineno_002c-performance-costs-375"></a><a name="index-trailing-context_002c-performance-costs-376"></a>
<pre class="example"><pre class="verbatim">         REJECT
         arbitrary trailing context
     
         pattern sets that require backing up
         %option yylineno
         %array
     
         %option interactive
         %option always-interactive
     
         @samp{^} beginning-of-line operator
         yymore()
</pre>
</pre>
   <p>with the first two all being quite expensive and the last two being
quite cheap.  Note also that <code>unput()</code> is implemented as a routine
call that potentially does quite a bit of work, while <code>yyless()</code> is
a quite-cheap macro. So if you are just putting back some excess text
you scanned, use <code>yyless()</code>.

   <p><code>REJECT</code> should be avoided at all costs when performance is
important.  It is a particularly expensive option.

   <p>There is one case when <code>%option yylineno</code> can be expensive. That is when
your patterns match long tokens that could <em>possibly</em> contain a newline
character. There is no performance penalty for rules that can not possibly
match newlines, since flex does not need to check them for newlines.  In
general, you should avoid rules such as <code>[^f]+</code>, which match very long
tokens, including newlines, and may possibly match your entire file! A better
approach is to separate <code>[^f]+</code> into two rules:

<pre class="example"><pre class="verbatim">     %option yylineno
     %%
         [^f\n]+
         \n+
</pre>
</pre>
   <p>The above scanner does not incur a performance penalty.

   <p><a name="index-patterns_002c-tuning-for-performance-377"></a><a name="index-performance_002c-backing-up-378"></a><a name="index-backing-up_002c-example-of-eliminating-379"></a>Getting rid of backing up is messy and often may be an enormous amount
of work for a complicated scanner.  In principal, one begins by using
the &lsquo;<samp><span class="samp">-b</span></samp>&rsquo; flag to generate a <samp><span class="file">lex.backup</span></samp> file.  For example,
on the input:

   <p><a name="index-backing-up_002c-eliminating-380"></a>
<pre class="example"><pre class="verbatim">         %%
         foo        return TOK_KEYWORD;
         foobar     return TOK_KEYWORD;
</pre>
</pre>
   <p>the file looks like:

<pre class="example"><pre class="verbatim">         State #6 is non-accepting -
          associated rule line numbers:
                2       3
          out-transitions: [ o ]
          jam-transitions: EOF [ \001-n  p-\177 ]
     
         State #8 is non-accepting -
          associated rule line numbers:
                3
          out-transitions: [ a ]
          jam-transitions: EOF [ \001-`  b-\177 ]
     
         State #9 is non-accepting -
          associated rule line numbers:
                3
          out-transitions: [ r ]
          jam-transitions: EOF [ \001-q  s-\177 ]
     
         Compressed tables always back up.
</pre>
</pre>
   <p>The first few lines tell us that there's a scanner state in which it can
make a transition on an 'o' but not on any other character, and that in
that state the currently scanned text does not match any rule.  The
state occurs when trying to match the rules found at lines 2 and 3 in
the input file.  If the scanner is in that state and then reads
something other than an 'o', it will have to back up to find a rule
which is matched.  With a bit of headscratching one can see that this
must be the state it's in when it has seen &lsquo;<samp><span class="samp">fo</span></samp>&rsquo;.  When this has
happened, if anything other than another &lsquo;<samp><span class="samp">o</span></samp>&rsquo; is seen, the scanner
will have to back up to simply match the &lsquo;<samp><span class="samp">f</span></samp>&rsquo; (by the default rule).

   <p>The comment regarding State #8 indicates there's a problem when
&lsquo;<samp><span class="samp">foob</span></samp>&rsquo; has been scanned.  Indeed, on any character other than an
&lsquo;<samp><span class="samp">a</span></samp>&rsquo;, the scanner will have to back up to accept "foo".  Similarly,
the comment for State #9 concerns when &lsquo;<samp><span class="samp">fooba</span></samp>&rsquo; has been scanned and
an &lsquo;<samp><span class="samp">r</span></samp>&rsquo; does not follow.

   <p>The final comment reminds us that there's no point going to all the
trouble of removing backing up from the rules unless we're using
&lsquo;<samp><span class="samp">-Cf</span></samp>&rsquo; or &lsquo;<samp><span class="samp">-CF</span></samp>&rsquo;, since there's no performance gain doing so
with compressed scanners.

   <p><a name="index-error-rules_002c-to-eliminate-backing-up-381"></a>The way to remove the backing up is to add &ldquo;error&rdquo; rules:

   <p><a name="index-backing-up_002c-eliminating-by-adding-error-rules-382"></a>
<pre class="example"><pre class="verbatim">         %%
         foo         return TOK_KEYWORD;
         foobar      return TOK_KEYWORD;
     
         fooba       |
         foob        |
         fo          {
                     /* false alarm, not really a keyword */
                     return TOK_ID;
                     }
</pre>
</pre>
   <p>Eliminating backing up among a list of keywords can also be done using a
&ldquo;catch-all&rdquo; rule:

   <p><a name="index-backing-up_002c-eliminating-with-catch_002dall-rule-383"></a>
<pre class="example"><pre class="verbatim">         %%
         foo         return TOK_KEYWORD;
         foobar      return TOK_KEYWORD;
     
         [a-z]+      return TOK_ID;
</pre>
</pre>
   <p>This is usually the best solution when appropriate.

   <p>Backing up messages tend to cascade.  With a complicated set of rules
it's not uncommon to get hundreds of messages.  If one can decipher
them, though, it often only takes a dozen or so rules to eliminate the
backing up (though it's easy to make a mistake and have an error rule
accidentally match a valid token.  A possible future <code>flex</code> feature
will be to automatically add rules to eliminate backing up).

   <p>It's important to keep in mind that you gain the benefits of eliminating
backing up only if you eliminate <em>every</em> instance of backing up. 
Leaving just one means you gain nothing.

   <p><em>Variable</em> trailing context (where both the leading and trailing
parts do not have a fixed length) entails almost the same performance
loss as <code>REJECT</code> (i.e., substantial).  So when possible a rule
like:

   <p><a name="index-trailing-context_002c-variable-length-384"></a>
<pre class="example"><pre class="verbatim">         %%
         mouse|rat/(cat|dog)   run();
</pre>
</pre>
   <p>is better written:

<pre class="example"><pre class="verbatim">         %%
         mouse/cat|dog         run();
         rat/cat|dog           run();
</pre>
</pre>
   <p>or as

<pre class="example"><pre class="verbatim">         %%
         mouse|rat/cat         run();
         mouse|rat/dog         run();
</pre>
</pre>
   <p>Note that here the special '|' action does <em>not</em> provide any
savings, and can even make things worse (see <a href="Limitations.html#Limitations">Limitations</a>).

   <p>Another area where the user can increase a scanner's performance (and
one that's easier to implement) arises from the fact that the longer the
tokens matched, the faster the scanner will run.  This is because with
long tokens the processing of most input characters takes place in the
(short) inner scanning loop, and does not often have to go through the
additional work of setting up the scanning environment (e.g.,
<code>yytext</code>) for the action.  Recall the scanner for C comments:

   <p><a name="index-performance-optimization_002c-matching-longer-tokens-385"></a>
<pre class="example"><pre class="verbatim">         %x comment
         %%
                 int line_num = 1;
     
         "/*"         BEGIN(comment);
     
         &lt;comment>[^*\n]*
         &lt;comment>"*"+[^*/\n]*
         &lt;comment>\n             ++line_num;
         &lt;comment>"*"+"/"        BEGIN(INITIAL);
</pre>
</pre>
   <p>This could be sped up by writing it as:

<pre class="example"><pre class="verbatim">         %x comment
         %%
                 int line_num = 1;
     
         "/*"         BEGIN(comment);
     
         &lt;comment>[^*\n]*
         &lt;comment>[^*\n]*\n      ++line_num;
         &lt;comment>"*"+[^*/\n]*
         &lt;comment>"*"+[^*/\n]*\n ++line_num;
         &lt;comment>"*"+"/"        BEGIN(INITIAL);
</pre>
</pre>
   <p>Now instead of each newline requiring the processing of another action,
recognizing the newlines is distributed over the other rules to keep the
matched text as long as possible.  Note that <em>adding</em> rules does
<em>not</em> slow down the scanner!  The speed of the scanner is
independent of the number of rules or (modulo the considerations given
at the beginning of this section) how complicated the rules are with
regard to operators such as &lsquo;<samp><span class="samp">*</span></samp>&rsquo; and &lsquo;<samp><span class="samp">|</span></samp>&rsquo;.

   <p><a name="index-keywords_002c-for-performance-386"></a><a name="index-performance_002c-using-keywords-387"></a>A final example in speeding up a scanner: suppose you want to scan
through a file containing identifiers and keywords, one per line
and with no other extraneous characters, and recognize all the
keywords.  A natural first approach is:

   <p><a name="index-performance-optimization_002c-recognizing-keywords-388"></a>
<pre class="example"><pre class="verbatim">         %%
         asm      |
         auto     |
         break    |
         ... etc ...
         volatile |
         while    /* it's a keyword */
     
         .|\n     /* it's not a keyword */
</pre>
</pre>
   <p>To eliminate the back-tracking, introduce a catch-all rule:

<pre class="example"><pre class="verbatim">         %%
         asm      |
         auto     |
         break    |
         ... etc ...
         volatile |
         while    /* it's a keyword */
     
         [a-z]+   |
         .|\n     /* it's not a keyword */
</pre>
</pre>
   <p>Now, if it's guaranteed that there's exactly one word per line, then we
can reduce the total number of matches by a half by merging in the
recognition of newlines with that of the other tokens:

<pre class="example"><pre class="verbatim">         %%
         asm\n    |
         auto\n   |
         break\n  |
         ... etc ...
         volatile\n |
         while\n  /* it's a keyword */
     
         [a-z]+\n |
         .|\n     /* it's not a keyword */
</pre>
</pre>
   <p>One has to be careful here, as we have now reintroduced backing up
into the scanner.  In particular, while
<em>we</em>
know that there will never be any characters in the input stream
other than letters or newlines,
<code>flex</code>
can't figure this out, and it will plan for possibly needing to back up
when it has scanned a token like &lsquo;<samp><span class="samp">auto</span></samp>&rsquo; and then the next character
is something other than a newline or a letter.  Previously it would
then just match the &lsquo;<samp><span class="samp">auto</span></samp>&rsquo; rule and be done, but now it has no &lsquo;<samp><span class="samp">auto</span></samp>&rsquo;
rule, only a &lsquo;<samp><span class="samp">auto\n</span></samp>&rsquo; rule.  To eliminate the possibility of backing up,
we could either duplicate all rules but without final newlines, or,
since we never expect to encounter such an input and therefore don't
how it's classified, we can introduce one more catch-all rule, this
one which doesn't include a newline:

<pre class="example"><pre class="verbatim">         %%
         asm\n    |
         auto\n   |
         break\n  |
         ... etc ...
         volatile\n |
         while\n  /* it's a keyword */
     
         [a-z]+\n |
         [a-z]+   |
         .|\n     /* it's not a keyword */
</pre>
</pre>
   <p>Compiled with &lsquo;<samp><span class="samp">-Cf</span></samp>&rsquo;, this is about as fast as one can get a
<code>flex</code> scanner to go for this particular problem.

   <p>A final note: <code>flex</code> is slow when matching <code>NUL</code>s,
particularly when a token contains multiple <code>NUL</code>s.  It's best to
write rules which match <em>short</em> amounts of text if it's anticipated
that the text will often include <code>NUL</code>s.

   <p>Another final note regarding performance: as mentioned in
<a href="Matching.html#Matching">Matching</a>, dynamically resizing <code>yytext</code> to accommodate huge
tokens is a slow process because it presently requires that the (huge)
token be rescanned from the beginning.  Thus if performance is vital,
you should attempt to match &ldquo;large&rdquo; quantities of text but not
&ldquo;huge&rdquo; quantities, where the cutoff between the two is at about 8K
characters per token.

   </body></html>

