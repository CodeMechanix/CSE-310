<html lang="en">
<head>
<title>The Default Memory Management - Lexical Analysis With Flex</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Lexical Analysis With Flex">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Memory-Management.html#Memory-Management" title="Memory Management">
<link rel="prev" href="Memory-Management.html#Memory-Management" title="Memory Management">
<link rel="next" href="Overriding-The-Default-Memory-Management.html#Overriding-The-Default-Memory-Management" title="Overriding The Default Memory Management">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
The flex manual is placed under the same licensing conditions as the
rest of flex:

Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007 The Flex
Project.

Copyright (C) 1990, 1997 The Regents of the University of California.
All rights reserved.

This code is derived from software contributed to Berkeley by
Vern Paxson.

The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
  1.  Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the
     distribution.

Neither the name of the University nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="The-Default-Memory-Management"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Overriding-The-Default-Memory-Management.html#Overriding-The-Default-Memory-Management">Overriding The Default Memory Management</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Memory-Management.html#Memory-Management">Memory Management</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Memory-Management.html#Memory-Management">Memory Management</a>
<hr>
</div>

<h3 class="section">21.1 The Default Memory Management</h3>

<p>Flex allocates dynamic memory during initialization, and once in a while from
within a call to yylex(). Initialization takes place during the first call to
yylex(). Thereafter, flex may reallocate more memory if it needs to enlarge a
buffer. As of version 2.5.9 Flex will clean up all memory when you call <code>yylex_destroy</code>
See <a href="faq_002dmemory_002dleak.html#faq_002dmemory_002dleak">faq-memory-leak</a>.

   <p>Flex allocates dynamic memory for four purposes, listed below <a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

     <dl>
<dt>16kB for the input buffer.<dd>Flex allocates memory for the character buffer used to perform pattern
matching.  Flex must read ahead from the input stream and store it in a large
character buffer.  This buffer is typically the largest chunk of dynamic memory
flex consumes. This buffer will grow if necessary, doubling the size each time. 
Flex frees this memory when you call yylex_destroy().  The default size of this
buffer (16384 bytes) is almost always too large.  The ideal size for this
buffer is the length of the longest token expected, in bytes, plus a little more.  Flex will allocate a few
extra bytes for housekeeping. Currently, to override the size of the input buffer
you must <code>#define YY_BUF_SIZE</code> to whatever number of bytes you want. We don't plan
to change this in the near future, but we reserve the right to do so if we ever add a more robust memory management
API.

     <br><dt>64kb for the REJECT state. This will only be allocated if you use REJECT.<dd>The size is the large enough to hold the same number of states as characters in the input buffer. If you override the size of the
input buffer (via <code>YY_BUF_SIZE</code>), then you automatically override the size of this buffer as well.

     <br><dt>100 bytes for the start condition stack.<dd>Flex allocates memory for the start condition stack. This is the stack used
for pushing start states, i.e., with yy_push_state(). It will grow if
necessary.  Since the states are simply integers, this stack doesn't consume
much memory.  This stack is not present if <code>%option stack</code> is not
specified.  You will rarely need to tune this buffer. The ideal size for this
stack is the maximum depth expected.  The memory for this stack is
automatically destroyed when you call yylex_destroy(). See <a href="option_002dstack.html#option_002dstack">option-stack</a>.

     <br><dt>40 bytes for each YY_BUFFER_STATE.<dd>Flex allocates memory for each YY_BUFFER_STATE. The buffer state itself
is about 40 bytes, plus an additional large character buffer (described above.) 
The initial buffer state is created during initialization, and with each call
to yy_create_buffer(). You can't tune the size of this, but you can tune the
character buffer as described above. Any buffer state that you explicitly
create by calling yy_create_buffer() is <em>NOT</em> destroyed automatically. You
must call yy_delete_buffer() to free the memory. The exception to this rule is
that flex will delete the current buffer automatically when you call
yylex_destroy(). If you delete the current buffer, be sure to set it to NULL. 
That way, flex will not try to delete the buffer a second time (possibly
crashing your program!) At the time of this writing, flex does not provide a
growable stack for the buffer states.  You have to manage that yourself. 
See <a href="Multiple-Input-Buffers.html#Multiple-Input-Buffers">Multiple Input Buffers</a>.

     <br><dt>84 bytes for the reentrant scanner guts<dd>Flex allocates about 84 bytes for the reentrant scanner structure when
you call yylex_init(). It is destroyed when the user calls yylex_destroy().

   </dl>

   <div class="footnote">
<hr>
<h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> The
quantities given here are approximate, and may vary due to host architecture,
compiler configuration, or due to future enhancements to flex.</p>

   <hr></div>

   </body></html>

