<html lang="en">
<head>
<title>Cxx - Lexical Analysis With Flex</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Lexical Analysis With Flex">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Performance.html#Performance" title="Performance">
<link rel="next" href="Reentrant.html#Reentrant" title="Reentrant">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
The flex manual is placed under the same licensing conditions as the
rest of flex:

Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007 The Flex
Project.

Copyright (C) 1990, 1997 The Regents of the University of California.
All rights reserved.

This code is derived from software contributed to Berkeley by
Vern Paxson.

The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
  1.  Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the
     distribution.

Neither the name of the University nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Cxx"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Reentrant.html#Reentrant">Reentrant</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Performance.html#Performance">Performance</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">18 Generating C++ Scanners</h2>

<p><a name="index-c_002b_002b_002c-experimental-form-of-scanner-class-389"></a><a name="index-experimental-form-of-c_002b_002b-scanner-class-390"></a><strong>IMPORTANT</strong>: the present form of the scanning class is <em>experimental</em>
and may change considerably between major releases.

   <p><a name="index-C_002b_002b-391"></a><a name="index-member-functions_002c-C_002b_002b-392"></a><a name="index-methods_002c-c_002b_002b-393"></a><code>flex</code> provides two different ways to generate scanners for use
with C++.  The first way is to simply compile a scanner generated by
<code>flex</code> using a C++ compiler instead of a C compiler.  You should
not encounter any compilation errors (see <a href="Reporting-Bugs.html#Reporting-Bugs">Reporting Bugs</a>).  You can
then use C++ code in your rule actions instead of C code.  Note that the
default input source for your scanner remains <samp><span class="file">yyin</span></samp>, and default
echoing is still done to <samp><span class="file">yyout</span></samp>.  Both of these remain <code>FILE
*</code> variables and not C++ <em>streams</em>.

   <p>You can also use <code>flex</code> to generate a C++ scanner class, using the
&lsquo;<samp><span class="samp">-+</span></samp>&rsquo; option (or, equivalently, <code>%option c++)</code>, which is
automatically specified if the name of the <code>flex</code> executable ends
in a '+', such as <code>flex++</code>.  When using this option, <code>flex</code>
defaults to generating the scanner to the file <samp><span class="file">lex.yy.cc</span></samp> instead
of <samp><span class="file">lex.yy.c</span></samp>.  The generated scanner includes the header file
<samp><span class="file">FlexLexer.h</span></samp>, which defines the interface to two C++ classes.

   <p>The first class,
<code>FlexLexer</code>,
provides an abstract base class defining the general scanner class
interface.  It provides the following member functions:

     
<a name="index-YYText-_0028C_002b_002b-only_0029-394"></a>
<dl><dt><code>const char* YYText()</code><dd>returns the text of the most recently matched token, the equivalent of
<code>yytext</code>.

     <p><a name="index-YYLeng-_0028C_002b_002b-only_0029-395"></a><br><dt><code>int YYLeng()</code><dd>returns the length of the most recently matched token, the equivalent of
<code>yyleng</code>.

     <p><a name="index-lineno-_0028C_002b_002b-only_0029-396"></a><br><dt><code>int lineno() const</code><dd>returns the current input line number (see <code>%option yylineno)</code>, or
<code>1</code> if <code>%option yylineno</code> was not used.

     <p><a name="index-set_005fdebug-_0028C_002b_002b-only_0029-397"></a><br><dt><code>void set_debug( int flag )</code><dd>sets the debugging flag for the scanner, equivalent to assigning to
<code>yy_flex_debug</code> (see <a href="Scanner-Options.html#Scanner-Options">Scanner Options</a>).  Note that you must build
the scanner using <code>%option debug</code> to include debugging information
in it.

     <p><a name="index-debug-_0028C_002b_002b-only_0029-398"></a><br><dt><code>int debug() const</code><dd>returns the current setting of the debugging flag. 
</dl>

   <p>Also provided are member functions equivalent to
<code>yy_switch_to_buffer()</code>, <code>yy_create_buffer()</code> (though the
first argument is an <code>istream*</code> object pointer and not a
<code>FILE*)</code>, <code>yy_flush_buffer()</code>, <code>yy_delete_buffer()</code>, and
<code>yyrestart()</code> (again, the first argument is a <code>istream*</code>
object pointer).

   <p><a name="index-yyFlexLexer-_0028C_002b_002b-only_0029-399"></a><a name="index-FlexLexer-_0028C_002b_002b-only_0029-400"></a>The second class defined in <samp><span class="file">FlexLexer.h</span></samp> is <code>yyFlexLexer</code>,
which is derived from <code>FlexLexer</code>.  It defines the following
additional member functions:

     
<a name="index-yyFlexLexer-constructor-_0028C_002b_002b-only_0029-401"></a>
<dl><dt><code>yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )</code><dd>constructs a <code>yyFlexLexer</code> object using the given streams for input
and output.  If not specified, the streams default to <code>cin</code> and
<code>cout</code>, respectively.

     <p><a name="index-yylex-_0028C_002b_002b-version_0029-402"></a><br><dt><code>virtual int yylex()</code><dd>performs the same role is <code>yylex()</code> does for ordinary <code>flex</code>
scanners: it scans the input stream, consuming tokens, until a rule's
action returns a value.  If you derive a subclass <code>S</code> from
<code>yyFlexLexer</code> and want to access the member functions and variables
of <code>S</code> inside <code>yylex()</code>, then you need to use <code>%option
yyclass="S"</code> to inform <code>flex</code> that you will be using that subclass
instead of <code>yyFlexLexer</code>.  In this case, rather than generating
<code>yyFlexLexer::yylex()</code>, <code>flex</code> generates <code>S::yylex()</code>
(and also generates a dummy <code>yyFlexLexer::yylex()</code> that calls
<code>yyFlexLexer::LexerError()</code> if called).

     <p><a name="index-switch_005fstreams-_0028C_002b_002b-only_0029-403"></a><br><dt><code>virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)</code><dd>reassigns <code>yyin</code> to <code>new_in</code> (if non-null) and <code>yyout</code> to
<code>new_out</code> (if non-null), deleting the previous input buffer if
<code>yyin</code> is reassigned.

     <br><dt><code>int yylex( istream* new_in, ostream* new_out = 0 )</code><dd>first switches the input streams via <code>switch_streams( new_in,
new_out )</code> and then returns the value of <code>yylex()</code>. 
</dl>

   <p>In addition, <code>yyFlexLexer</code> defines the following protected virtual
functions which you can redefine in derived classes to tailor the
scanner:

     
<a name="index-LexerInput-_0028C_002b_002b-only_0029-404"></a>
<dl><dt><code>virtual int LexerInput( char* buf, int max_size )</code><dd>reads up to <code>max_size</code> characters into <code>buf</code> and returns the
number of characters read.  To indicate end-of-input, return 0
characters.  Note that <code>interactive</code> scanners (see the &lsquo;<samp><span class="samp">-B</span></samp>&rsquo;
and &lsquo;<samp><span class="samp">-I</span></samp>&rsquo; flags in <a href="Scanner-Options.html#Scanner-Options">Scanner Options</a>) define the macro
<code>YY_INTERACTIVE</code>.  If you redefine <code>LexerInput()</code> and need to
take different actions depending on whether or not the scanner might be
scanning an interactive input source, you can test for the presence of
this name via <code>#ifdef</code> statements.

     <p><a name="index-LexerOutput-_0028C_002b_002b-only_0029-405"></a><br><dt><code>virtual void LexerOutput( const char* buf, int size )</code><dd>writes out <code>size</code> characters from the buffer <code>buf</code>, which, while
<code>NUL</code>-terminated, may also contain internal <code>NUL</code>s if the
scanner's rules can match text with <code>NUL</code>s in them.

     <p><a name="index-error-reporting_002c-in-C_002b_002b-406"></a><a name="index-LexerError-_0028C_002b_002b-only_0029-407"></a><br><dt><code>virtual void LexerError( const char* msg )</code><dd>reports a fatal error message.  The default version of this function
writes the message to the stream <code>cerr</code> and exits. 
</dl>

   <p>Note that a <code>yyFlexLexer</code> object contains its <em>entire</em>
scanning state.  Thus you can use such objects to create reentrant
scanners, but see also <a href="Reentrant.html#Reentrant">Reentrant</a>.  You can instantiate multiple
instances of the same <code>yyFlexLexer</code> class, and you can also combine
multiple C++ scanner classes together in the same program using the
&lsquo;<samp><span class="samp">-P</span></samp>&rsquo; option discussed above.

   <p>Finally, note that the <code>%array</code> feature is not available to C++
scanner classes; you must use <code>%pointer</code> (the default).

   <p>Here is an example of a simple C++ scanner:

   <p><a name="index-C_002b_002b-scanners_002c-use-of-408"></a>
<pre class="example"><pre class="verbatim">             // An example of using the flex C++ scanner class.
     
         %{
         int mylineno = 0;
         %}
     
         string  \"[^\n"]+\"
     
         ws      [ \t]+
     
         alpha   [A-Za-z]
         dig     [0-9]
         name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
         num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
         num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
         number  {num1}|{num2}
     
         %%
     
         {ws}    /* skip blanks and tabs */
     
         "/*"    {
                 int c;
     
                 while((c = yyinput()) != 0)
                     {
                     if(c == '\n')
                         ++mylineno;
     
                     else if(c == @samp{*})
                         {
                         if((c = yyinput()) == '/')
                             break;
                         else
                             unput(c);
                         }
                     }
                 }
     
         {number}  cout  "number "  YYText()  '\n';
     
         \n        mylineno++;
     
         {name}    cout  "name "  YYText()  '\n';
     
         {string}  cout  "string "  YYText()  '\n';
     
         %%
     
         int main( int /* argc */, char** /* argv */ )
             {
             @code{flex}Lexer* lexer = new yyFlexLexer;
             while(lexer->yylex() != 0)
                 ;
             return 0;
             }
</pre>
</pre>
   <p><a name="index-C_002b_002b_002c-multiple-different-scanners-409"></a>If you want to create multiple (different) lexer classes, you use the
&lsquo;<samp><span class="samp">-P</span></samp>&rsquo; flag (or the <code>prefix=</code> option) to rename each
<code>yyFlexLexer</code> to some other &lsquo;<samp><span class="samp">xxFlexLexer</span></samp>&rsquo;.  You then can
include <samp><span class="file">&lt;FlexLexer.h&gt;</span></samp> in your other sources once per lexer class,
first renaming <code>yyFlexLexer</code> as follows:

   <p><a name="index-include-files_002c-with-C_002b_002b-410"></a><a name="index-header-files_002c-with-C_002b_002b-411"></a><a name="index-C_002b_002b-scanners_002c-including-multiple-scanners-412"></a>
<pre class="example"><pre class="verbatim">         #undef yyFlexLexer
         #define yyFlexLexer xxFlexLexer
         #include &lt;FlexLexer.h>
     
         #undef yyFlexLexer
         #define yyFlexLexer zzFlexLexer
         #include &lt;FlexLexer.h>
</pre>
</pre>
   <p>if, for example, you used <code>%option prefix="xx"</code> for one of your
scanners and <code>%option prefix="zz"</code> for the other.

   </body></html>

