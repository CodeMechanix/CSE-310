<html lang="en">
<head>
<title>Actions - Lexical Analysis With Flex</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Lexical Analysis With Flex">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="prev" href="Matching.html#Matching" title="Matching">
<link rel="next" href="Generated-Scanner.html#Generated-Scanner" title="Generated Scanner">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
The flex manual is placed under the same licensing conditions as the
rest of flex:

Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007 The Flex
Project.

Copyright (C) 1990, 1997 The Regents of the University of California.
All rights reserved.

This code is derived from software contributed to Berkeley by
Vern Paxson.

The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
  1.  Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the
     distribution.

Neither the name of the University nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Actions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Generated-Scanner.html#Generated-Scanner">Generated Scanner</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Matching.html#Matching">Matching</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="index.html#Top">Top</a>
<hr>
</div>

<h2 class="chapter">8 Actions</h2>

<p><a name="index-actions-96"></a>Each pattern in a rule has a corresponding <dfn>action</dfn>, which can be
any arbitrary C statement.  The pattern ends at the first non-escaped
whitespace character; the remainder of the line is its action.  If the
action is empty, then when the pattern is matched the input token is
simply discarded.  For example, here is the specification for a program
which deletes all occurrences of &lsquo;<samp><span class="samp">zap me</span></samp>&rsquo; from its input:

   <p><a name="index-deleting-lines-from-input-97"></a>
<pre class="example"><pre class="verbatim">         %%
         "zap me"
</pre>
</pre>
   <p>This example will copy all other characters in the input to the output
since they will be matched by the default rule.

   <p>Here is a program which compresses multiple blanks and tabs down to a
single blank, and throws away whitespace found at the end of a line:

   <p><a name="index-whitespace_002c-compressing-98"></a><a name="index-compressing-whitespace-99"></a>
<pre class="example"><pre class="verbatim">         %%
         [ \t]+        putchar( ' ' );
         [ \t]+$       /* ignore this token */
</pre>
</pre>
   <p><a name="index-g_t_0025_0040_007b-and-_0025_0040_007d_002c-in-Rules-Section-100"></a><a name="index-actions_002c-use-of-_0040_007b-and-_0040_007d-101"></a><a name="index-actions_002c-embedded-C-strings-102"></a><a name="index-C_002dstrings_002c-in-actions-103"></a><a name="index-comments_002c-in-actions-104"></a>If the action contains a &lsquo;<samp><span class="samp">{</span></samp>&rsquo;, then the action spans till the
balancing &lsquo;<samp><span class="samp">}</span></samp>&rsquo; is found, and the action may cross multiple lines. 
<code>flex</code> knows about C strings and comments and won't be fooled by
braces found within them, but also allows actions to begin with
&lsquo;<samp><span class="samp">%{</span></samp>&rsquo; and will consider the action to be all the text up to the
next &lsquo;<samp><span class="samp">%}</span></samp>&rsquo; (regardless of ordinary braces inside the action).

   <p><a name="index-g_t_007c_002c-in-actions-105"></a>An action consisting solely of a vertical bar (&lsquo;<samp><span class="samp">|</span></samp>&rsquo;) means &ldquo;same as the
action for the next rule&rdquo;.  See below for an illustration.

   <p>Actions can include arbitrary C code, including <code>return</code> statements
to return a value to whatever routine called <code>yylex()</code>.  Each time
<code>yylex()</code> is called it continues processing tokens from where it
last left off until it either reaches the end of the file or executes a
return.

   <p><a name="index-yytext_002c-modification-of-106"></a>Actions are free to modify <code>yytext</code> except for lengthening it
(adding characters to its end&ndash;these will overwrite later characters in
the input stream).  This however does not apply when using <code>%array</code>
(see <a href="Matching.html#Matching">Matching</a>). In that case, <code>yytext</code> may be freely modified
in any way.

   <p><a name="index-yyleng_002c-modification-of-107"></a><a name="index-yymore_002c-and-yyleng-108"></a>Actions are free to modify <code>yyleng</code> except they should not do so if
the action also includes use of <code>yymore()</code> (see below).

   <p><a name="index-preprocessor-macros_002c-for-use-in-actions-109"></a>There are a number of special directives which can be included within an
action:

     <dl>
<dt><code>ECHO</code><dd><a name="index-ECHO-110"></a>copies yytext to the scanner's output.

     <br><dt><code>BEGIN</code><dd><a name="index-BEGIN-111"></a>followed by the name of a start condition places the scanner in the
corresponding start condition (see below).

     <br><dt><code>REJECT</code><dd><a name="index-REJECT-112"></a>directs the scanner to proceed on to the &ldquo;second best&rdquo; rule which
matched the input (or a prefix of the input).  The rule is chosen as
described above in <a href="Matching.html#Matching">Matching</a>, and <code>yytext</code> and <code>yyleng</code>
set up appropriately.  It may either be one which matched as much text
as the originally chosen rule but came later in the <code>flex</code> input
file, or one which matched less text.  For example, the following will
both count the words in the input and call the routine <code>special()</code>
whenever &lsquo;<samp><span class="samp">frob</span></samp>&rsquo; is seen:

     <pre class="example">     <pre class="verbatim">                      int word_count = 0;
              %%
          
              frob        special(); REJECT;
              [^ \t\n]+   ++word_count;
     </pre>
</pre>
     <p>Without the <code>REJECT</code>, any occurrences of &lsquo;<samp><span class="samp">frob</span></samp>&rsquo; in the input
would not be counted as words, since the scanner normally executes only
one action per token.  Multiple uses of <code>REJECT</code> are allowed, each
one finding the next best choice to the currently active rule.  For
example, when the following scanner scans the token &lsquo;<samp><span class="samp">abcd</span></samp>&rsquo;, it will
write &lsquo;<samp><span class="samp">abcdabcaba</span></samp>&rsquo; to the output:

     <p><a name="index-REJECT_002c-calling-multiple-times-113"></a><a name="index-g_t_007c_002c-use-of-114"></a>
     <pre class="example">     <pre class="verbatim">              %%
              a        |
              ab       |
              abc      |
              abcd     ECHO; REJECT;
              .|\n     /* eat up any unmatched character */
     </pre>
</pre>
     <p>The first three rules share the fourth's action since they use the
special &lsquo;<samp><span class="samp">|</span></samp>&rsquo; action.

     <p><code>REJECT</code> is a particularly expensive feature in terms of scanner
performance; if it is used in <em>any</em> of the scanner's actions it
will slow down <em>all</em> of the scanner's matching.  Furthermore,
<code>REJECT</code> cannot be used with the &lsquo;<samp><span class="samp">-Cf</span></samp>&rsquo; or &lsquo;<samp><span class="samp">-CF</span></samp>&rsquo; options
(see <a href="Scanner-Options.html#Scanner-Options">Scanner Options</a>).

     <p>Note also that unlike the other special actions, <code>REJECT</code> is a
<em>branch</em>.  Code immediately following it in the action will
<em>not</em> be executed.

     <br><dt><code>yymore()</code><dd><a name="index-yymore_0028_0029-115"></a>tells the scanner that the next time it matches a rule, the
corresponding token should be <em>appended</em> onto the current value of
<code>yytext</code> rather than replacing it.  For example, given the input
&lsquo;<samp><span class="samp">mega-kludge</span></samp>&rsquo; the following will write &lsquo;<samp><span class="samp">mega-mega-kludge</span></samp>&rsquo; to
the output:

     <p><a name="index-yymore_0028_0029_002c-mega_002dkludge-116"></a><a name="index-yymore_0028_0029-to-append-token-to-previous-token-117"></a>
     <pre class="example">     <pre class="verbatim">              %%
              mega-    ECHO; yymore();
              kludge   ECHO;
     </pre>
</pre>
     <p>First &lsquo;<samp><span class="samp">mega-</span></samp>&rsquo; is matched and echoed to the output.  Then &lsquo;<samp><span class="samp">kludge</span></samp>&rsquo;
is matched, but the previous &lsquo;<samp><span class="samp">mega-</span></samp>&rsquo; is still hanging around at the
beginning of
<code>yytext</code>
so the
<code>ECHO</code>
for the &lsquo;<samp><span class="samp">kludge</span></samp>&rsquo; rule will actually write &lsquo;<samp><span class="samp">mega-kludge</span></samp>&rsquo;. 
</dl>

   <p><a name="index-yymore_002c-performance-penalty-of-118"></a>Two notes regarding use of <code>yymore()</code>.  First, <code>yymore()</code>
depends on the value of <code>yyleng</code> correctly reflecting the size of
the current token, so you must not modify <code>yyleng</code> if you are using
<code>yymore()</code>.  Second, the presence of <code>yymore()</code> in the
scanner's action entails a minor performance penalty in the scanner's
matching speed.

   <p><a name="index-yyless_0028_0029-119"></a><code>yyless(n)</code> returns all but the first <code>n</code> characters of the
current token back to the input stream, where they will be rescanned
when the scanner looks for the next match.  <code>yytext</code> and
<code>yyleng</code> are adjusted appropriately (e.g., <code>yyleng</code> will now
be equal to <code>n</code>).  For example, on the input &lsquo;<samp><span class="samp">foobar</span></samp>&rsquo; the
following will write out &lsquo;<samp><span class="samp">foobarbar</span></samp>&rsquo;:

   <p><a name="index-yyless_0028_0029_002c-pushing-back-characters-120"></a><a name="index-pushing-back-characters-with-yyless-121"></a>
<pre class="example"><pre class="verbatim">         %%
         foobar    ECHO; yyless(3);
         [a-z]+    ECHO;
</pre>
</pre>
   <p>An argument of 0 to <code>yyless()</code> will cause the entire current input
string to be scanned again.  Unless you've changed how the scanner will
subsequently process its input (using <code>BEGIN</code>, for example), this
will result in an endless loop.

   <p>Note that <code>yyless()</code> is a macro and can only be used in the flex
input file, not from other source files.

   <p><a name="index-unput_0028_0029-122"></a><a name="index-pushing-back-characters-with-unput-123"></a><code>unput(c)</code> puts the character <code>c</code> back onto the input stream. 
It will be the next character scanned.  The following action will take
the current token and cause it to be rescanned enclosed in parentheses.

   <p><a name="index-unput_0028_0029_002c-pushing-back-characters-124"></a><a name="index-pushing-back-characters-with-unput_0028_0029-125"></a>
<pre class="example"><pre class="verbatim">         {
         int i;
         /* Copy yytext because unput() trashes yytext */
         char *yycopy = strdup( yytext );
         unput( ')' );
         for ( i = yyleng - 1; i >= 0; --i )
             unput( yycopy[i] );
         unput( '(' );
         free( yycopy );
         }
</pre>
</pre>
   <p>Note that since each <code>unput()</code> puts the given character back at the
<em>beginning</em> of the input stream, pushing back strings must be done
back-to-front.

   <p><a name="index-g_t_0025pointer_002c-and-unput_0028_0029-126"></a><a name="index-unput_0028_0029_002c-and-_0025pointer-127"></a>An important potential problem when using <code>unput()</code> is that if you
are using <code>%pointer</code> (the default), a call to <code>unput()</code>
<em>destroys</em> the contents of <code>yytext</code>, starting with its
rightmost character and devouring one character to the left with each
call.  If you need the value of <code>yytext</code> preserved after a call to
<code>unput()</code> (as in the above example), you must either first copy it
elsewhere, or build your scanner using <code>%array</code> instead
(see <a href="Matching.html#Matching">Matching</a>).

   <p><a name="index-pushing-back-EOF-128"></a><a name="index-EOF_002c-pushing-back-129"></a>Finally, note that you cannot put back &lsquo;<samp><span class="samp">EOF</span></samp>&rsquo; to attempt to mark the
input stream with an end-of-file.

   <p><a name="index-input_0028_0029-130"></a><code>input()</code> reads the next character from the input stream.  For
example, the following is one way to eat up C comments:

   <p><a name="index-comments_002c-discarding-131"></a><a name="index-discarding-C-comments-132"></a>
<pre class="example"><pre class="verbatim">         %%
         "/*"        {
                     register int c;
     
                     for ( ; ; )
                         {
                         while ( (c = input()) != '*' &amp;&amp;
                                 c != EOF )
                             ;    /* eat up text of comment */
     
                         if ( c == '*' )
                             {
                             while ( (c = input()) == '*' )
                                 ;
                             if ( c == '/' )
                                 break;    /* found the end */
                             }
     
                         if ( c == EOF )
                             {
                             error( "EOF in comment" );
                             break;
                             }
                         }
                     }
</pre>
</pre>
   <p><a name="index-input_0028_0029_002c-and-C_002b_002b-133"></a><a name="index-yyinput_0028_0029-134"></a>(Note that if the scanner is compiled using <code>C++</code>, then
<code>input()</code> is instead referred to as <b>yyinput()</b>, in order to
avoid a name clash with the <code>C++</code> stream by the name of
<code>input</code>.)

   <p><a name="index-flushing-the-internal-buffer-135"></a><a name="index-YY_005fFLUSH_005fBUFFER_0028_0029-136"></a><code>YY_FLUSH_BUFFER()</code> flushes the scanner's internal buffer so that
the next time the scanner attempts to match a token, it will first
refill the buffer using <code>YY_INPUT()</code> (see <a href="Generated-Scanner.html#Generated-Scanner">Generated Scanner</a>). 
This action is a special case of the more general
<code>yy_flush_buffer()</code> function, described below (see <a href="Multiple-Input-Buffers.html#Multiple-Input-Buffers">Multiple Input Buffers</a>)

   <p><a name="index-yyterminate_0028_0029-137"></a><a name="index-terminating-with-yyterminate_0028_0029-138"></a><a name="index-exiting-with-yyterminate_0028_0029-139"></a><a name="index-halting-with-yyterminate_0028_0029-140"></a><code>yyterminate()</code> can be used in lieu of a return statement in an
action.  It terminates the scanner and returns a 0 to the scanner's
caller, indicating &ldquo;all done&rdquo;.  By default, <code>yyterminate()</code> is
also called when an end-of-file is encountered.  It is a macro and may
be redefined.

   </body></html>

